import{v as e,u as a,f as t,I as n,g as s,h as o,i as r,l as u,d as c}from"./server.mjs";import{G as i}from"../nitro/nitro.mjs";import{u as l}from"./composables-BaIXnRa0.mjs";import"../routes/renderer.mjs";import"../_/shared.esm-bundler.mjs";const d={trailing:!0};function debounce(e,a=25,t={}){if(t={...d,...t},!Number.isFinite(a))throw new TypeError("Expected `wait` to be a finite number");let n,s,o,r,u=[];const applyFn=(a,n)=>(o=async function(e,a,t){return await e.apply(a,t)}(e,a,n),o.finally(()=>{if(o=null,t.trailing&&r&&!s){const e=applyFn(a,r);return r=null,e}}),o),debounced=function(...e){return t.trailing&&(r=e),o||new Promise(o=>{const c=!s&&t.leading;clearTimeout(s),s=setTimeout(()=>{s=null;const a=t.leading?n:applyFn(this,e);r=null;for(const e of u)e(a);u=[]},a),c?(n=applyFn(this,e),o(n)):u.push(o)})},_clearTimeout=e=>{e&&(clearTimeout(e),s=null)};return debounced.isPending=()=>!!s,debounced.cancel=()=>{_clearTimeout(s),u=[],r=null},debounced.flush=()=>{if(_clearTimeout(s),!r||o)return;const e=r;return r=null,applyFn(this,e)},debounced}function useAsyncData(...t){const n="string"==typeof t[t.length-1]?t.pop():void 0;_isAutoKeyNeeded(t[0],t[1])&&t.unshift(n);let[s,r,u={}]=t;const i=e.computed(()=>e.toValue(s));if("string"!=typeof i.value)throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if("function"!=typeof r)throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const l=a();u.server??=!0,u.default??=getDefault,u.getCachedData??=getDefaultCachedData,u.lazy??=!1,u.immediate??=!0,u.deep??=o.deep,u.dedupe??="cancel",u._functionName,l._asyncData[i.value];const d={cause:"initial",dedupe:u.dedupe};l._asyncData[i.value]?._init||(d.cachedData=u.getCachedData(i.value,l,{cause:"initial"}),l._asyncData[i.value]=function(a,t,n,s,o){a.payload._errors[t]??=void 0;const r=s.getCachedData!==getDefaultCachedData,u=n,i=s.deep?e.ref:e.shallowRef,l=void 0!==o,d=a.hook("app:data:refresh",async e=>{e&&!e.includes(t)||await f.execute({cause:"refresh:hook"})}),f={data:i(l?o:s.default()),pending:e.computed(()=>"pending"===f.status.value),error:e.toRef(a.payload._errors,t),status:e.shallowRef("idle"),execute:(...n)=>{const[o,r]=n,i=o&&void 0===r&&"object"==typeof o?o:{};if(a._asyncDataPromises[t]){if("defer"===(i.dedupe??s.dedupe))return a._asyncDataPromises[t];a._asyncDataPromises[t].cancelled=!0}{const e="cachedData"in i?i.cachedData:s.getCachedData(t,a,{cause:i.cause??"refresh:manual"});if(void 0!==e)return a.payload.data[t]=f.data.value=e,f.error.value=void 0,f.status.value="success",Promise.resolve(e)}f.status.value="pending";const l=new Promise((e,t)=>{try{e(u(a))}catch(e){t(e)}}).then(async e=>{if(l.cancelled)return a._asyncDataPromises[t];let n=e;s.transform&&(n=await s.transform(e)),s.pick&&(n=function(e,a){const t={};for(const n of a)t[n]=e[n];return t}(n,s.pick)),a.payload.data[t]=n,f.data.value=n,f.error.value=void 0,f.status.value="success"}).catch(n=>{if(l.cancelled)return a._asyncDataPromises[t];f.error.value=c(n),f.data.value=e.unref(s.default()),f.status.value="error"}).finally(()=>{l.cancelled||delete a._asyncDataPromises[t]});return a._asyncDataPromises[t]=l,a._asyncDataPromises[t]},_execute:debounce((...e)=>f.execute(...e),0,{leading:!0}),_default:s.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{d(),a._asyncData[t]?._init&&(a._asyncData[t]._init=!1),r||e.nextTick(()=>{a._asyncData[t]?._init||(clearNuxtDataByKey(a,t),f.execute=()=>Promise.resolve())})}};return f}(l,i.value,r,u,d.cachedData));l._asyncData[i.value]._deps++;if(!1!==u.server&&l.payload.serverRendered&&u.immediate){const a=l._asyncData[i.value].execute(d);e.getCurrentInstance()?e.onServerPrefetch(()=>a):l.hook("app:created",async()=>{await a})}const f={data:writableComputedRef(()=>l._asyncData[i.value]?.data),pending:writableComputedRef(()=>l._asyncData[i.value]?.pending),status:writableComputedRef(()=>l._asyncData[i.value]?.status),error:writableComputedRef(()=>l._asyncData[i.value]?.error),refresh:(...e)=>l._asyncData[i.value].execute(...e),execute:(...e)=>l._asyncData[i.value].execute(...e),clear:()=>clearNuxtDataByKey(l,i.value)},m=Promise.resolve(l._asyncDataPromises[i.value]).then(()=>f);return Object.assign(m,f),m}function writableComputedRef(a){return e.computed({get:()=>a()?.value,set(e){const t=a();t&&(t.value=e)}})}function useLazyAsyncData(...e){const a="string"==typeof e[e.length-1]?e.pop():void 0;_isAutoKeyNeeded(e[0],e[1])&&e.unshift(a);const[t,n,s={}]=e;return useAsyncData(t,n,{...s,lazy:!0},null)}function _isAutoKeyNeeded(e,a){return"string"!=typeof e&&(("object"!=typeof e||null===e)&&("function"!=typeof e||"function"!=typeof a))}function clearNuxtDataByKey(a,t){t in a.payload.data&&(a.payload.data[t]=void 0),t in a.payload._errors&&(a.payload._errors[t]=void 0),a._asyncData[t]&&(a._asyncData[t].data.value=e.unref(a._asyncData[t]._default()),a._asyncData[t].error.value=void 0,a._asyncData[t].status.value="idle"),t in a._asyncDataPromises&&(a._asyncDataPromises[t]&&(a._asyncDataPromises[t].cancelled=!0),a._asyncDataPromises[t]=void 0)}const getDefault=()=>{},getDefaultCachedData=(e,a,t)=>a.isHydrating?a.payload.data[e]:"refresh:manual"!==t.cause&&"refresh:hook"!==t.cause?a.static.data[e]:void 0;async function loadIcon(e,a){if(!e)return null;const t=r(e);if(t)return t;let n;const s=u(e).catch(()=>(console.warn(`[Icon] failed to load icon \`${e}\``),null));return a>0?await Promise.race([s,new Promise(t=>{n=setTimeout(()=>{console.warn(`[Icon] loading icon \`${e}\` timed out after ${a}ms`),t()},a)})]).finally(()=>clearTimeout(n)):await s,r(e)}function useResolvedName(a){const n=t().icon,s=(n.collections||[]).sort((e,a)=>a.length-e.length);return e.computed(()=>{const e=a(),t=e.startsWith(n.cssSelectorPrefix)?e.slice(n.cssSelectorPrefix.length):e,o=n.aliases?.[t]||t;if(!o.includes(":")){const e=s.find(e=>o.startsWith(e+"-"));return e?e+":"+o.slice(e.length+1):o}return o})}function resolveCustomizeFn(e,a){if(!1!==e)return!0===e||null===e?a:e}const f="NUXT_ICONS_SERVER_CSS";const m=e.defineComponent({name:"NuxtIconCss",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(n){const o=a(),r=t().icon,u=e.computed(()=>n.name?r.cssSelectorPrefix+n.name:""),c=e.computed(()=>"."+function(e){return e.replace(/([^\w-])/g,"\\$1")}(u.value));return e.onServerPrefetch(async()=>{{const e=s().icon||{};if(!e?.serverKnownCssClasses?.includes(u.value)){const e=await loadIcon(n.name,r.fetchTimeout).catch(()=>null);if(!e)return null;let a=o.vueApp._context.provides[f];if(a||(a=o.vueApp._context.provides[f]=new Map,o.runWithContext(()=>{l({style:[()=>{let e=Array.from(a.values()).sort().join("");return r.cssLayer&&(e=`@layer ${r.cssLayer} {${e}}`),{innerHTML:e}}]},{tagPriority:"low"})})),n.name&&!a.has(n.name)){const t=function(e,a=!0){let t=c.value;r.cssWherePseudo&&(t=`:where(${t})`);const s=i(e,{iconSelector:t,format:"compressed",customise:resolveCustomizeFn(n.customize,r.customize)});return r.cssLayer&&a?`@layer ${r.cssLayer} { ${s} }`:s}(e,!1);a.set(n.name,t)}return null}}}),()=>e.h("span",{class:["iconify",u.value]})}}),y=e.defineComponent({name:"NuxtIconSvg",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(s,{slots:o}){a();const r=t().icon,u=useResolvedName(()=>s.name),c="i-"+u.value;return u.value&&e.onServerPrefetch(async()=>{await useAsyncData(c,async()=>await loadIcon(u.value,r.fetchTimeout),{deep:!1})}),()=>e.h(n,{icon:u.value,ssr:!0,customise:resolveCustomizeFn(s.customize,r.customize)},o)}}),p=e.defineComponent({name:"NuxtIcon",props:{name:{type:String,required:!0},mode:{type:String,required:!1,default:null},size:{type:[Number,String],required:!1,default:null},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(n,{slots:s}){const o=a(),r=t().icon,u=useResolvedName(()=>n.name),c=e.computed(()=>o.vueApp?.component(u.value)||("svg"===(n.mode||r.mode)?y:m)),i=e.computed(()=>{const e=n.size||r.size;return e?{fontSize:Number.isNaN(+e)?e:e+"px"}:null});return()=>e.h(c.value,{...r.attrs,name:u.value,class:r.class,style:i.value,customize:n.customize},s)}}),v=Object.freeze(Object.defineProperty({__proto__:null,default:p},Symbol.toStringTag,{value:"Module"}));export{p as _,v as i,useLazyAsyncData as u};
//# sourceMappingURL=index-Bb3avKMy.mjs.map
